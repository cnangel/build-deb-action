#!/usr/bin/perl
#
# This script should only depend on packages perl-base (essential) and
# libdpkg-perl.
#

use strict;
use warnings;

use feature 'say';

use Cwd qw(abs_path);
use Dpkg::Checksums;
use Dpkg::Control;
use File::Copy;
use File::Path qw(make_path);
use File::Spec;

my $input_artifacts_dir = $ENV{INPUT_ARTIFACTS_DIR};
my $input_source_dir    = $ENV{INPUT_SOURCE_DIR};
my $artifacts_src_dir   = File::Spec->catfile( $input_source_dir, q{..} );
my $changes_filename;
my $rc = 0;

open my $files_fh, '<', File::Spec->catfile( $input_source_dir, 'debian/files' )
  or die "Failed to open debian/files: $!";
while (<$files_fh>) {

    # Following the Debian policy, a (source) package name can contain “lower
    # case letters (a-z), digits (0-9), plus (+) and minus (-) signs, and
    # periods (.)”[1] and the version additionally a colon (:) and “the
    # characters . + - ~ (full stop, plus, hyphen, tilde)”[2]. An architecture
    # contains alphanumeric, lower case characters. Package name, version, and
    # architecture are separated by underscores (_).
    #
    # The simpler `/^([^ ]+.buildinfo) .*/` would also be sufficient here.
    #
    # [1] https://www.debian.org/doc/debian-policy/ch-controlfields.html#source
    # [2] https://www.debian.org/doc/debian-policy/ch-controlfields.html#version
    if (/^([a-z0-9:.+~_-]+.buildinfo) .*/) {
        $changes_filename = $1 =~ s/[.]buildinfo$/.changes/r;
        last;
    }
}
close $files_fh or warn 'Failed to close debian/files';

die 'Did not find the .buildinfo file in debian/files'
  if not defined $changes_filename;
my $changes_file = File::Spec->catfile( $artifacts_src_dir, $changes_filename );
die 'Cannot find the .changes file' if !-e $changes_file;

my $changes = Dpkg::Control->new( type => CTRL_FILE_CHANGES );
$changes->load($changes_file);

my $checksums = Dpkg::Checksums->new();
$checksums->add_from_control($changes);

my @artifacts = sort $changes_filename, $checksums->get_files();

if ( !-e $input_artifacts_dir ) {
    make_path( $input_artifacts_dir, { error => \my $mkdir_err } );
    if ( $mkdir_err && $mkdir_err->@* ) {
        die "Failed to create artifacts_dir '$input_artifacts_dir': "
          . ( $mkdir_err->[0]->%* )[1];
    }
}
elsif ( !-d $input_artifacts_dir ) {
    die "artifacts_dir '$input_artifacts_dir' exists but is not a directory";
}

if ( abs_path($artifacts_src_dir) ne abs_path($input_artifacts_dir) ) {
    for my $artifact (@artifacts) {
        my $artifact_file =
          File::Spec->catfile( $artifacts_src_dir, $artifact );
        if ( move( $artifact_file, $input_artifacts_dir ) ) {
            say "Moved '$artifact' '$input_artifacts_dir'";
        }
        else {
            warn "Failed to move '$artifact': $!";
            $rc = 1;
        }
    }
}
else {
    for (@artifacts) {
        say "Not moving '$_', already in the right directory";
    }
}

exit $rc;
